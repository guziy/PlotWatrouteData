__author__="huziy"
__date__ ="$Jul 23, 2011 1:04:49 PM$"



from data.rivdis_station_metadata import RivDisStationManager
from transforms.affine import AffineTransform
from data.basin import Basin
from data.cell import Cell
from mpl_toolkits.basemap import NetCDFFile
from mpl_toolkits.basemap import Basemap

import netCDF4 as nc

import numpy as np

import matplotlib.pyplot as plt
import application_properties

import data.direction_and_value as direction_and_value
import os

from shapely.geometry import Point, Polygon


import pdb

###This class is used to generate basins

class CellManager():
    def __init__(self, path = ''):
        '''
        path is a path to netcdf file containing directions
        generated by DDM upscaling module
        '''
        self.ncFile = NetCDFFile(path)
        self.cells = []
        self.basins = []

        self.list_of_cells_1d = []



        lonData = self.ncFile.variables['lon'].data
        latData = self.ncFile.variables['lat'].data

        self.nx, self.ny = lonData.shape

        
        self.longitudes = lonData[:,:]
        self.latitudes = latData[:,:]
        self.accumulation_area = self.ncFile.variables['accumulation_area'].data
        
        #init cells
        self._create_cells()
        print 'created cells'
        self._connect_cells()
        print 'connected the cells'
        #put the cells to basins
        self._determine_basins()
        print 'identified basins'

        #create shapely polygons corresponding to the basins
        self._create_corresponding_polygons()
        print 'created polygons corresponding to the grid cells'

    def _create_cells(self):

        self.cells = [
            [Cell(ix = i, jy = j) for j in xrange(self.ny)] for i in xrange(self.nx)
        ]


    def _connect_cells(self):
        '''
        Inits and connects underlying cell list
        '''

        flowDirValues = self.ncFile.variables['flow_direction_value'].data
        print self.nx, self.ny


        for i in xrange(self.nx):
            for j in xrange(self.ny):
                iNext, jNext = direction_and_value.to_indices(i, j, flowDirValues[i, j])
                if iNext >= 0 and iNext < self.nx and jNext >= 0 and jNext < self.ny:
                    self.cells[i][j].set_next(self.cells[iNext][jNext])

        #calculate number of previous cells for each cell
        for i in xrange(self.nx):
            for j in xrange(self.ny):
                theCell = self.cells[i][j]
                if theCell.number_of_upstream_cells >= 0:
                    continue
                theCell.calculate_number_of_upstream_cells()

        

    def _create_corresponding_polygons(self):
        aft = AffineTransform()
        #image polygon
        image = Polygon([(-1.0,-1.0), (1.0,-1.0), (1.0,1.0), (-1.0, 1.0), (-1.0, -1.0)])
        #reference points
        p1 = Point(0.0, 0.0)
        p2 = Point(1.0, 0.0)
        p3 = Point(0.0, 1.0)
        p4 = Point(-1.0, 0.0)
        p5 = Point(0.0, -1.0)

        pi1 = p1
        print 'lon min, max',self.longitudes.min(), self.longitudes.max()
        for i in xrange(self.nx):
            for j in xrange(self.ny):
                theCell = self.cells[i][j]
                x1, y1 = self.longitudes[i,j], self.latitudes[i, j]
                if i == self.nx - 1:
                    x2, y2 = self.longitudes[i - 1, j], self.latitudes[i - 1, j]
                    pi2 = p4
                else:
                    x2, y2 = self.longitudes[i + 1,j], self.latitudes[i + 1, j]
                    pi2 = p2

                if j == self.ny - 1:
                    x3, y3 = self.longitudes[i, j - 1], self.latitudes[i, j - 1]
                    pi3 = p5
                else:
                    x3, y3 = self.longitudes[i, j + 1], self.latitudes[i, j + 1]
                    pi3 = p3


                ##transform longitudes to -180, 180
                x1 = x1 if x1 <= 180 else x1 - 360
                x2 = x2 if x2 <= 180 else x2 - 360
                x3 = x3 if x3 <= 180 else x3 - 360


                x2 = 0.5 * (x1 + x2)
                y2 = 0.5 * (y1 + y2)

                x3 = 0.5 * (x1 + x3)
                y3 = 0.5 * (y1 + y3)

                #assert x1 < 150 and x2 < 150 and x3 < 150
                #print x1,y1, x2,y2, x3,y3
                srcToDest = {
                    pi1 : Point(x1, y1),
                    pi2 : Point(x2, y2),
                    pi3 : Point(x3, y3)
                }
                aft.define_from_points(srcToDest)
                # @type theCell Cell
                theCell.polygon = aft.transform(image)
#                print theCell.polygon.wkt
#                print aft.transform(p1).wkt
                pass
        


    def _determine_basins(self):
        '''
        Determine list of basins
        '''
        
        for i in xrange(self.nx):
            for j in xrange(self.ny):
                theCell = self.cells[i][j]

                if theCell.basin != None:
                    continue
                
                #go to the exit point
                while theCell.next != None:
                    theCell = theCell.next

                #single cell is not considered as a basin
                # @type theCell Cell
                if len(theCell.previous) == 0 or theCell.number_of_upstream_cells <= 45:
                    continue

                basin = Basin(id = len(self.basins))
                basin.name = 'Basin_{0}'.format(basin.id)
                self.basins.append(basin)

                #assign the basin to all the cells flowing into it
                theCell.set_common_basin(basin)
        
                

    def plot_basins(self):
        basin_values = -np.ones((self.nx, self.ny))
        for basin in self.basins:

            # @type basin Basin
            #if int(basin.name.split('_')[1]) not in [0,4,1,11,15,20,22,25]: continue

            for theCell in basin.cells:
                # @type theCell Cell
                i, j = theCell.coords()

                theValue = basin.id if theCell.next != None else -2
                basin_values[i,j] = theValue

        basin_values = np.ma.masked_where(basin_values == -1, basin_values)
        lons, lats = self.longitudes, self.latitudes
        lons = lons.copy()
        lons[lons <= 180] += 360
        lon_min = np.min(lons)
        lon_max = np.max(lons)
        lat_min = np.min(lats)
        lat_max = np.max(lats)

        basemap = Basemap(llcrnrlon = lon_min, llcrnrlat = lat_min,
                          urcrnrlon = lon_max, urcrnrlat = lat_max,
                          resolution = 'i'
                        )
        lons, lats = basemap(lons, lats)
        colormap = plt.cm.get_cmap(name = 'prism', lut = len(self.basins))
        colormap.set_under(color = 'k')

        basemap.pcolormesh(lons, lats, basin_values, cmap = colormap, vmin = 0)

        basemap.drawcoastlines()
        plt.show()
        #plt.savefig('basins.png')


    def save_basins_mask(self):
        dataset = nc.Dataset('africa_basin_mask.nc', 'w', format = 'NETCDF3_CLASSIC')

        dataset.createDimension('lon', self.nx)
        dataset.createDimension('lat', self.ny)

        #save also lons, lats and drainage areas
        var = dataset.createVariable('longitude', 'f4', ('lon', 'lat'))
        var.units = 'west-east degrees'
        var.description = 'real longitude'
        var[:] = self.longitudes


        var = dataset.createVariable('latitude', 'f4', ('lon', 'lat'))
        var.units = 'south-north degrees'
        var.description = 'real latitude'
        var[:] = self.latitudes

        var = dataset.createVariable('accumulation_area', 'f4', ('lon', 'lat'))
        var.units = 'km ** 2'
        var.description = 'accumulation area'
        var[:] = self.accumulation_area




        for i, basin in enumerate(self.basins):
            varName = basin.name
            mask = np.zeros((self.nx, self.ny))
            # @type theCell Cell
            for theCell in basin.cells:
                if theCell.next == None:
                    mask[theCell.x, theCell.y] = -1
                else:
                    mask[theCell.x, theCell.y] = 1
            var = dataset.createVariable(varName, 'i4', ('lon', 'lat'))
            var[:] = mask

        dataset.close()


    
    def _get_point_with_closest_drainage(self, i0, j0, di, dj, station_accum_area):
        i_guess = i0
        j_guess = j0
        d_guess = _abs_diff(station_accum_area, self.accumulation_area[i_guess, j_guess])
        for i in xrange(i0 - di, i0 + di + 1):
            for j in xrange(j0 - dj, j0 + dj + 1):
                d1 = _abs_diff(station_accum_area, self.accumulation_area[i, j])
                if d1 < d_guess:
                    i_guess = i
                    j_guess = j
                    d_guess = d1
                    
        return self.cells[i_guess][j_guess]

    def get_info_corresponding_to_stations(self, stations):
        
        new_station_list = []
        new_station_list.extend(stations)
        for i in xrange(self.nx):
            for j in xrange(self.ny):
                theCell = self.cells[i][j]
                lastConsideredStation = None # for better performance
                for station in new_station_list:
                    if theCell.basin == None: continue
                    # @type theCell Cell
                    if theCell.polygon.intersects(station.point):
                        # @type station RivDisStationMeta
                        station_da = station.drainage_area
                        if station_da > 0:
                            theCell_guess = self._get_point_with_closest_drainage(i, j, 2, 2, station_da)
                        else:
                            theCell_guess = theCell
                        station.basin = theCell.basin.name
                        # @type station RivDisStationMeta
                        station.model_i = theCell_guess.x
                        station.model_j = theCell_guess.y
                        station.gridcell_polygon = theCell_guess.polygon
                        print station.name, theCell.basin.name
                        lastConsideredStation = station

                if lastConsideredStation != None: new_station_list.remove(lastConsideredStation)
        pass

    def test_contains(self):
        p = Point((19.54, -32.34))
        for i in xrange(self.nx):
            for j in xrange(self.ny):
                theCell = self.cells[i][j]
                # @type theCell Cell
                print theCell.polygon.distance(p)
                if theCell.polygon.contains(p):
                    print p.wkt
                    print theCell.polygon.wkt
                    print theCell.basin.name
                    print i, j
                    return
        print p.wkt


def _abs_diff(a, b):
    return np.abs(a - b)

 

def get_model_info_for_rivdis_stations(cm):
    '''
    Generate basin mask and save it to the netcdf file
    1 - basin cell
    0 - not a basin cell
    -1 - outlet of the basin
    '''
    #read in available station metadata
    rm = RivDisStationManager()
    rm.parseStationMetaData()
    cm.get_info_corresponding_to_stations(rm.getStations())

    rm.saveStationsMetaData()
    
def test():
    folder = 'data/hydrosheds'
    file_path = os.path.join(folder, 'directions_af_parallel_crop.nc')
    cm = CellManager(path = file_path)
    cm.test_contains()

    pass


def main():
    folder = 'data/hydrosheds'
    file_path = os.path.join(folder, 'directions_af_parallel_crop.nc')
    cm = CellManager(path = file_path)
    get_model_info_for_rivdis_stations(cm)

    #cm.save_basins_mask()
    #cm.plot_basins()


def debug():
    pdb.run('main()')


if __name__ == "__main__":
    application_properties.set_current_directory()

#    test()
    main()
    print "Hello World"
