import os.path
__author__="huziy"
__date__ ="$8 dec. 2010 10:20:08$"


from mpl_toolkits.basemap import NetCDFFile
from plot2D.calculate_forcing_errors import get_indices_from_file
from data.data_select import get_data_from_file
import application_properties
application_properties.set_current_directory()
from readers.read_infocell import plot_basin_boundaries_from_shape
import os
import sys
from math import *
import numpy as np
import pickle



from data.cehq_station import Station
from util.geo.lat_lon import get_distance_in_meters
from plot2D.map_parameters import polar_stereographic
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import pylab
import matplotlib as mpl


MAXIMUM_DISTANCE_METERS = 45000.0 #m

TIME_FORMAT = '%Y_%m_%d_%H_%M'

lons = polar_stereographic.lons
lats = polar_stereographic.lats


inches_per_pt = 1.0 / 72.27               # Convert pt to inch
golden_mean = (sqrt(5.0) - 1.0) / 2.0       # Aesthetic ratio
fig_width = 1000 * inches_per_pt          # width in inches
fig_height = fig_width * golden_mean      # height in inches
fig_size = [fig_width, 1.8 * fig_height]

params = {
        'axes.labelsize': 15,
        'font.size': 15,
        'text.fontsize': 20,
        'legend.fontsize': 20,
        'xtick.labelsize': 15,
        'ytick.labelsize': 16,
        'figure.figsize': fig_size
        }



#needed for calculation of mean of data for each day
def create_dates_of_year(date_list = [], year = 2000):
    result = []

    for d1 in date_list:
        try:
            result.append(datetime(year, d1.month, d1.day, d1.hour, d1.minute, d1.second))
        except ValueError:
            print 'warning in create_dates_of_year: day is out of range for month'
    return result



def objective_function(distance, da1, da2):
    alpha = 1
    return distance / MAXIMUM_DISTANCE_METERS + np.abs(da2 - da1) / da1 * alpha



def get_closest_station(lon, lat, cell_drain_area_km2, station_list):
    '''
    returns the closest station to (lon, lat),
    or None if it was not found
    '''
    #find distance to the closest station
    objective = None
    result = None
    for station in station_list:
        station_drainage = station.drainage_km2
        distance = get_distance_in_meters(lon, lat, station.longitude, station.latitude)
        objective1 = objective_function(distance, station_drainage, cell_drain_area_km2)
        
        if objective == None:
            objective = objective1
            result = station
        else:
            if objective1 < objective:
                result = station
                objective = objective1
        
            
    if objective <= 0.7:
        return result
    else:
        return None




def read_station_data(folder = 'data/cehq_measure_data'):
    stations = []
    for file in os.listdir(folder):
        if not '.txt' in file:
            continue
        path = os.path.join(folder, file)
        s = Station()
        s.parse_from_cehq(path)
        stations.append(s)
    return stations




def get_from_file(path, varname):
    nc = NetCDFFile(path)
    data = nc.variables[varname].data
    nc.close()
    return data


def average_for_each_day_of_year(times, data, start_date = None, end_date = None, year = 2001):
    values = {}
    counts = {}

    assert len(times) == len(data)

    dates = create_dates_of_year(times, year = year)
    result_values = []
    result_dates = []

    for date, time, the_value in zip(dates, times, data):

        if start_date != None and end_date != None:
            if time < start_date or time > end_date:
                continue

        if values.has_key(date):
            values[date] += the_value
            counts[date] += 1
        else:
            values[date] = the_value
            counts[date] = 1


    dt = timedelta(days = 1)
    d = datetime(year, 1, 1, 0, 0)
    while d.year == year:
        if values.has_key(d):
            values[d] /= float(counts[d])
            result_values.append(values[d])
            result_dates.append(d)
        d += dt
    return result_dates, result_values
        
 
def calculate_skills(selected_stations = [], 
                    selected_station_dates = [], selected_station_values = [],
                    selected_dates_with_gw = [],
                    selected_values_with_gw = [],
                    grid_drainages = [],
                    grid_lons = [], grid_lats = []):

    for i in range(len(selected_stations)):
         the_dates_station = selected_station_dates[i]
         the_dates_model = selected_dates_with_gw[i]
         values_gw = selected_values_with_gw[i]
         station = selected_stations[i]
         station_values = selected_station_values[i]
         the_dates = the_dates_station if len(the_dates_station) <= len(the_dates_model) else the_dates_model

         values_gw_list = []
         station_values_list = []
         for index, the_date in enumerate(the_dates):
            if the_dates == the_dates_station:
                station_values_list.append(station_values[index])
                index_model = the_dates_model.index(the_date)
                values_gw_list.append(values_gw[index_model])
            else:
                index_station = the_dates_station.index(the_date)
                station_values_list.append(station_values[index_station])
                values_gw_list.append(values_gw[index])
            



         values_gw = np.array(values_gw_list)
         station_values = np.array(station_values_list)


         

         grid_drainage  = grid_drainages[i]
         grid_lon = grid_lons[i]
         grid_lat = grid_lats[i]

#         values_without_gw = selected_values_without_gw[i]


         #calculate skill coefficient
         std1 = np.std(values_gw)
         std2 = np.std(station_values)
         R = np.corrcoef(values_gw, station_values)
         S = 2 * std1 * std2 / (std1 ** 2 + std2 ** 2) * R[0,1]


#         print 'Station:'
#         print 'Id,Lon, Lat, DA: %s, %f, %f, %f' % ( station.id, station.longitude, station.latitude, station.drainage_km2 )
#         print 'Grid point'
#         print 'Lon, Lat, DA, Skill, dDA/DA : %f, %f, %f, %f, %f' % (grid_lon, grid_lat, grid_drainage,
#                                    S, (grid_drainage - station.drainage_km2) / station.drainage_km2 )

         print '%s & %.2f & %.2f & %.2f ' % ( station.id, station.longitude, station.latitude, station.drainage_km2 )
         print '& %.2f &  %.2f & %.2f & %.2f & %.2f \\\\' % (grid_lon, grid_lat, grid_drainage,
                                    S, (grid_drainage - station.drainage_km2) / station.drainage_km2 * 100 )
         print '\\hline'
 #        print '=============='





def main():

    pylab.rcParams.update(params)
    path = 'data/streamflows/hydrosheds_euler1/aex_discharge_1970_01_01_00_00.nc'
    data, times, i_list, j_list = get_data_from_file(path)
    drainage_area = get_from_file(path, 'drainage')


    stations_dump = 'stations_dump.bin'
    if os.path.isfile(stations_dump):
        print 'unpickling'
        stations = pickle.load(open(stations_dump))
    else:
        stations = read_station_data()
        pickle.dump(stations, open(stations_dump, 'w'))

   
    reload(sys)
    sys.setdefaultencoding('iso-8859-1')

    da_2d = np.zeros(lons.shape)
    for index, i, j in zip( range(len(i_list)) , i_list, j_list):
        da_2d[i, j] = drainage_area[index]
       


    selected_stations = []

    selected_dates_with_gw = []
    selected_values_with_gw = []

    selected_station_dates = []
    selected_station_values = []

    grid_drainages = []
    grid_lons = []
    grid_lats = []


    plt.figure()
    nfigures = len(selected_stations)
    current_subplot = 1

    label1 = 'model'
    label2 = 'measurement'
    override = {'fontsize': 20}
    plt.subplots_adjust(hspace = 0.8)
    nfigcols = 2


    for index, i, j in zip( range(len(i_list)) , i_list, j_list):
        station = get_closest_station(lons[i, j], lats[i, j], da_2d[i, j], stations)
        
        if station == None or station in selected_stations:
            continue



        #found station plot data
        print station.name


        start_date = max( np.min(times), np.min(station.dates) )
        end_date = min( np.max(times),  np.max(station.dates) )



        if end_date < start_date:
            continue

        plt.subplot(7, 2, current_subplot)
        current_subplot += 1


        grid_drainages.append(da_2d[i, j])
        grid_lons.append(lons[i, j])
        grid_lats.append(lats[i, j])


        #calculate values and dates for hydrographs
        dates, values = average_for_each_day_of_year(times, data[:,index], start_date = start_date,
                                                                           end_date = end_date,
                                                                           year = 2000)
        selected_dates_with_gw.append(dates)
        selected_values_with_gw.append(values)

        line1, = plt.plot(dates, values)



        dates, values = average_for_each_day_of_year(station.dates, station.values,
                                                     start_date = start_date,
                                                     end_date = end_date, year = 2000)
        line2, = plt.plot(dates, values, color = 'r')

        
        plt.yticks([0, np.round(np.max(values) / 2), np.round(np.max(values))])

        selected_station_dates.append(dates)
        selected_station_values.append(values)


        selected_stations.append(station)
        
        plt.title(station.id, override)
        ax = plt.gca()
        ax.xaxis.set_major_locator(
            mpl.dates.MonthLocator(bymonth = range(1,13,2))
        )


        ax.xaxis.set_major_formatter(
            mpl.dates.DateFormatter('%b')
        )


    lines = (line1, line2)
    plt.figlegend(lines, [label1, label2],'lower right')
    plt.savefig('performance_error.png', bbox_inches='tight')

    
   # assert len(selected_dates_with_gw[0]) == len(selected_station_dates[0])

    calculate_skills(selected_stations,
                    selected_station_dates, selected_station_values,
                    selected_dates_with_gw, selected_values_with_gw,
                    grid_drainages,
                    grid_lons, grid_lats)
    plot_selected_stations(selected_stations)


def plot_selected_stations(selected_stations):
    plt.clf()
    basemap = polar_stereographic.basemap
    basemap.drawcoastlines()
    basemap.drawrivers(color = 'blue')
    plot_basin_boundaries_from_shape(basemap, 1)
    for station in selected_stations:
        x, y = basemap(station.longitude, station.latitude)

        xtext = 1.005 * x
        ytext = y
        if station.id in ['061906']:
            xtext = 1.00 * x
            ytext = 0.97 * y

        if station.id in ['103603', '081007']:
            ytext = 0.98 * y


        plt.annotate(station.id, xy = (x, y), xytext = (xtext, ytext),
                     bbox = dict(facecolor = 'white')
                     #arrowprops=dict(facecolor='black', shrink=0.001)
                     )
        basemap.scatter(x,y, c = 'r', s = 100, marker='^', linewidth = 0, alpha = 1)

    ymin, ymax = plt.ylim()
    plt.ylim(ymin + 0.12 * (ymax - ymin), ymax * 0.33)

    xmin, xmax = plt.xlim()
    plt.xlim(xmin + (xmax - xmin) * 0.65, 0.86*xmax)

    plt.savefig('selected_stations.png',  bbox_inches='tight')

if __name__ == "__main__":
    main()
    print "Hello World"
